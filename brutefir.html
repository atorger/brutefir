<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BruteFIR</title>

  <style>
    body {
      max-width: 50rem;
      margin: 0 auto;
      padding: 1rem;
      font-family: "Arial", "Helvetica", sans-serif;
    }

    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    th, td {
      padding: 0.3em;
    }

    h1, h2, h3 {
      line-height: 1.2;
    }
    code, pre {
	font-family: "Liberation Mono", "DejaVu Sans Mono", "Consolas", monospace;
    }
    ul li, ol li {
	margin-bottom: 0.4em;
    }
  </style>
</head>

<body>
<h1>BruteFIR</h1>
<h2>Table of contents</h2>
<ul>
  <li><a href="brutefir.html#news">News</a></li>
  <li><a href="brutefir.html#download">Download</a></li>
  <li><a href="brutefir.html#whatisit">What is it?</a></li>
  <li><a href="brutefir.html#whatisitfor">What is it for?</a></li>
  <li><a href="brutefir.html#integration">How to use and integrate</a></li>
  <li><a href="brutefir.html#config">Configuring and running</a></li>
    <ul>
      <li><a href="brutefir.html#config_1">General settings</a></li>
      <li><a href="brutefir.html#config_2">General structure syntax</a></li>
      <li><a href="brutefir.html#config_3">Coeff structure</a></li>
      <li><a href="brutefir.html#config_4">Input and output structure</a></li>
      <li><a href="brutefir.html#config_5">Filter structure</a></li>
      <li><a href="brutefir.html#config_6">Configuration file example</a></li>
    </ul>
  <li><a href="brutefir.html#bfio">I/O modules</a></li>
    <ul>
      <li><a href="brutefir.html#bfio_alsa">ALSA sound card I/O (alsa)</a></li>
      <li><a href="brutefir.html#bfio_jack">JACK audio server I/O (jack)</a></li>
      <li><a href="brutefir.html#bfio_pipewire">PipeWire multimedia server I/O (pipewire)</a></li>
      <li><a href="brutefir.html#bfio_file">Raw PCM file I/O (file)</a></li>
      <li><a href="brutefir.html#bfio_own">Writing your own I/O module</a></li>
    </ul>
  <li><a href="brutefir.html#bflogic">Logic modules</a></li>
    <ul>
      <li><a href="brutefir.html#bflogic_cli">Command line interface (cli)</a></li>
      <li><a href="brutefir.html#bflogic_eq">Run-time equalizer</a></li>
      <li><a href="brutefir.html#bflogic_own">Writing your own logic module</a></li>
    </ul>
  <li><a href="brutefir.html#tuning">Tuning</a></li>
    <ul>
      <li><a href="brutefir.html#tuning_1">Realtime index</a></li>
      <li><a href="brutefir.html#tuning_2">Sample clock problems</a></li>
    </ul>
</ul>
<p>

<h2 id="news">News</h2>
<p><strong>2026-01-19</strong><br>
  Release 1.1.1, fixed a couple of super-old bugs related to muting
  and delaying devices with 24 bit (3 byte) samples.
</p>
<p><strong>2025-11-23</strong><br>
  Here's release 1.1.0 and a big refresher of code and
  documentation. BruteFIR was originally developed back in 2000, and
  has since about 2006 been "complete" and in maintenance
  mode. The stability has made it a reference no-nonsense embeddable
  convolution engine still in use today.
</p>
<p>
  Some of the old-school aspects of the original design has however
  become a hindrance in some contexts, particularly the use of
  multiple processes to employ multiple CPU cores (BruteFIR was
  devised in a time when Linux pthreads could only use one core, and
  all CPU power available was certainly needed to do heavier work like
  auralization and wavefield synthesis). The big change in this
  release is therefore a move to single process and threads.
</p>
<p>
  Other old school features are kept though, like the C-library based
  module interface and the command line interface, and in essence it's
  compatible with older versions and configuration files. If you have
  custom modules you need to at least recompile them though.
</p>
<p>
  On to the details of this 1.1.0 release:
  <ul>
    <li>Now runs threaded instead of multi-processes, which makes it
      more compatible with modern sound servers, and module interface
      easier to understand for developers that are unfamiliar with how
      fork() works.
    </li>
    <li>
      Open source license changed from GPL to ISC, to make it easier
      to use by commercial projects.
    </li>
    <li>
      Change versioning system to major.minor.patch.
    </li>
    <li>
      New I/O module: PipeWire I/O.
    </li>
    <li>
      Use XDG_CONFIG_HOME and XDG_CACHE_CONFIG ~/.config/ and ~/.cache/
      for default config and FFTW wisdom respectively.
    </li>
    <li>
      Add optional SINGLE_MOD_PATH compile flag to lock modules path to
      one directory (like /usr/lib/brutefir), which is recommended when
      building a package for a Linux distro.
    </li>
    <li>
      ALSA I/O: add support for mmap modes.
    </li>
    <li>
      ALSA I/O: add "access" option to ALSA I/O module to force a
      specific access mode, often necessary with the ALSA Loopback driver.
    </li>
    <li>
      ALSA I/O: switch input devices to input mode if they falsely always
      report data available (PipeWire/virtual device workaround).
    </li>
    <li>
      ALSA I/O: better error messages for incompatible parameters.
    </li>
    <li>
      Very minor changes to integration APIs due to threaded model.
    </li>
    <li>
      Make code C99 compliant (with a bit of POSIX).
    </li>
    <li>
      JACK I/O: print error message for dynamic buffer sizes.
    </li>
    <li>
      Remove Sparc/SunOS and FreeBSD-specific code.
    </li>
    <li>
      Remove obsolete OSS I/O module.
    </li>
    <li>
      Fix minor dither bug.
    </li>
    <li>The documentation of this page has been refreshed and
    simplified. Old documentation still left in
    the <a href="brutefir-archive.html">archived
    documentation</a>.</li>
  </ul>
</p>
<p><strong>Older news</strong><br>
  Older news are available in the <a href="brutefir-archive.html">archived documentation</a>.
</p>

<h2 id="download">Download</h2>
<p>
  You are free to <a href="files/brutefir-1.1.1.tar.gz">download version 1.1.1</a>.
</p>
<p>
  For reference, the soruce code is also
  on <a href="https://github.com/atorger/brutefir">github</a>, but as
  this is a legacy low maintenance project the github procedures for
  releases and packages are not used (you may use it for bug reporting
  though). The official release is found on this webpage as the
  downloadable archive.
</p>

<h2 id="whatisit">What is it?</h2>
<p>
BruteFIR is a software convolution engine, a program for
applying long FIR filters to multi-channel digital audio, either
offline or in realtime. Its basic operation is specified through a
configuration file, and filters, attenuation and delay can be changed
in runtime through a simple command line interface. The FIR filter
algorithm used is an optimized and partitioned frequency domain
algorithm, thus throughput is extremely high, and I/O-delay can be
kept fairly low.
</p>
<p>
Through its highly modular design, things like adaptive filtering,
signal generators and sample I/O are easily added, extended and
modified, without the need to alter the program itself.
</p><p>
BruteFIR is free and open-source. It is licensed through the ISC
License (a simplified MIT/BSD), which make it easy to integrate
everywhere even commercial projects.
</p>
<p>
While it's most popularly used on embedded platforms directly
integrated with ALSA, it can also be used on desktop computers,
integrating natively also with JACK and PipeWire.
</p>

<ul>
  <li>Designed for realtime filtering of HiFi quality digital audio</li>
  <li>Up to 256 inputs and 256 outputs (compile-time constant)</li>
  <li>Input/output provided by external modules for maximum flexibility</li>
  <ul>
    <li>Default I/O modules provide support for sound cards and files</li>
    <li>Access multiple I/O modules (= several sound cards / files) at the same time</li>
    <li>8 - 32 bit audio at any rate supported by sound cards</li>
    <li>Easy-to-use C language API to create your own I/O modules, for
      example to support more file formats, other sound card APIs, or
      generate test signals
    </li>
  </ul>
  <li>Mix/copy channels before and/or after filtering</li>
  <li>Cascade filters or build complex filter graphs</li>
  <li>Simple C language API to create logic modules, to add new
    functionality</li>
  <ul>
    <li>Create your own logic module, for example to do adaptive filtering</li>
    <li>Provided is a logic module which implements a CLI accessible
      through telnet to manage runtime settings, and a dynamic equalizer.</li>
    <li>Toggle/change filter in runtime</li>
    <li>Alter attenuation for each individual input and output in runtime</li>
    <li>Alter delay for each individual input and output in runtime</li>
    <li>Sub-sample delays are possible</li>
  </ul>
  <li>Filter length limited only by processor power and memory</li>
  <li>Typical filter lengths are in the range 2048 - 262144 taps</li>
  <li>Uses uniform partitioned convolution algorithm for filtering, so
    you can choose a tradeoff between I/O-delay and CPU usage</li>
  <li>Reasonable low I/O-delay (=short partition size) achievable for
    most applications.</li>
  <li>Fixed I/O-delay, thus possible to sample-align with other processors</li>
  <li>Cross-fade for seamless filter coefficient changes.</li>
  <li>Re-dithering of outputs (HP TPDF)</li>
  <li>Overflow protection and monitoring</li>
  <li>32 or 64 bit floating point internal resolution.</li>
  <li>Supports processing over multiple CPU cores</li>
</ul>
</p>

<h2 id="whatisitfor">What is it for?</h2>
<p>
A few examples of applications where BruteFIR can be a central component:
</p>
<p>
<ul>
  <li>Digital crossover filters</li>
  <li>Room equalization</li>
  <li>Cross-talk cancellation</li>
  <li>Wavefield synthesis</li>
  <li>Reverb</li>
  <li>Auralization</li>
  <li>Ambiophonics</li>
  <li>Ambisonics</li>
</ul>
</p>
<p>
Many of these applications need only short filters, but for example
auralization may need filters that are several seconds long. BruteFIR
works well for both.
</p>
<p>
Note that to actually use BruteFIR in these applications you need to
design the filters in other software. The package does include an
equalizer plugin though, so out of the box you can use it as an
equalizer, which you can control live through the provided CLI module.
</p>

<h2 id="integration">How to use and integrate</h2>
<p>
BruteFIR can be used out of the box on a Linux desktop computer, and
then you typically use JACK or PipeWire I/O and static configuration
with your desired filters that you have designed in some other
software.
</p>
<p>
  This is a basic use case:
<ol>
  <li>You have a Linux desktop computer with a PipeWire sound server.</li>
  <li>Use some other software to generate FIR filters and save to files.</li>
  <li>Make your BruteFIR configuration file with your filter graph
    and link to PipeWire source and sinks.</li>
  <li>Run BruteFIR from the command line, pointing out your
    configuration file.</li>
  <li>While BruteFIR is running, connect to its CLI using telnet
    and write text commands to make live changes.</li>
</ol>
</p>
<p>
It's very well suited for and was originally designed to be used in
embedded contexts though, ie headless computers made dedicated for
processing audio. In that case you usually use the ALSA I/O module and
connect it directly to the hardware drivers without any sound server
inbetween. If it needs to be chained with other software, JACK is the
preferred interface, although ALSA loopback can also be used (it's a
bit quirky to set up though).
</p>
<p>
If you are a software developer that wants to use BruteFIR as your
filter engine for your project, the typical way to integrate is to not
modify BruteFIR software at all, but possibly make custom I/O or logic
modules and control it all using the CLI sending text commands. The
controlling application could of course be written in any language.
</p>
<p>
The module interface is a bit old-school by today's standards, but if
you don't want to use C you can wrap the API and use any language you
prefer.
</p>
<p>
BruteFIR should be quite easy to port to MacOS and Windows, but for
now the source code only supports Linux, and as embedded is its most
popular use case, Linux is the way to go.
</p>
<p>
  Here is a typical full integration use case:
</p>
<ul>
  <li>Write a separate controlling application in any language that
    handles filter generation and control of BruteFIR.</li>
  <li>The controlling application launches BruteFIR, connects its standard
    input to where it sends the configuration.</li>
  <li>The controlling application uses a pipe to connect the the
    BruteFIR CLI to make live changes.</li>
  <li>If any filter coeffients needs live changing they are stored in
    shared memory and double-buffered so the controlling application
    can modify them in runtime.</li>
</ul>

<h2 id="config">Configuring and running</h2>
<p>
When BruteFIR is run for the first time without parameters, it will
generate a default configuration file at
<code>~/.config/BruteFIR/brutefir_defaults.conf</code> (unless
the <code>-nodefault</code> option is used), and then complain
that it cannot find the main configuration file at its default
location <code>~/.config/BruteFIR/brutefir.conf</code>.
The default configuration file contains default settings, which is
extended and/or overridden in the main configuration file. A setting
that is specified in the default configuration file does not need to
be in the main.
</p>
<p>
BruteFIR takes only four parameters, namely the
filename of the main configuration file, and optionally
<code>-quiet</code> to suppress title, warnings and informational messages
at startup, and <code>-nodefault</code> if BruteFIR should read all
settings from the main configuration file, and finally
the legacy setting <code>-daemon</code> if it should run as a daemon
(today setting up a systemd unit file is the normal way to run it as a
daemon).
</p>
<p>
If no parameters are given, the filename given in the default
configuration file is used. If the filename is "stdin", BruteFIR will
expect the configuration file to be available on the standard input,
a useful option for integration projects.
</p><p>
The (default) default configuration file looks like this:
</p>

<pre>
## DEFAULT GENERAL SETTINGS ##

float_bits: 32;             # internal floating point precision
sampling_rate: 44100;       # sampling rate in Hz of audio interfaces
filter_length: 65536;       # length of filters
config_file: "$XDG_CONFIG_HOME/BruteFIR/brutefir.conf"; # standard location of main config file
overflow_warnings: true;    # echo warnings to stderr if overflow occurs
show_progress: true;        # echo filtering progress to stderr
max_dither_table_size: 0;   # maximum size in bytes of precalculated dither
allow_poll_mode: false;     # allow use of input poll mode
modules_path: ".";          # extra path where to find BruteFIR modules
powersave: false;           # pause filtering when input is zero
monitor_rate: false;        # monitor sample rate
lock_memory: true;          # try to lock memory if realtime prio is set
sdf_length: -1;             # subsample filter half length in samples
convolver_config: "$XDG_CACHE_HOME/BruteFIR/brutefir_convolver_wisdom"; # FFTW wisdom

## COEFF DEFAULTS ##

coeff {
        format: "text";     # file format
        attenuation: 0.0;   # attenuation in dB
	blocks: -1;         # how long in blocks
	skip: 0;            # how many bytes to skip
	shared_mem: false;  # allocate in shared memory
};

## INPUT DEFAULTS ##

input {
        device: "file" {};  # module and parameters to get audio
        sample: "S16_LE";   # sample format
        channels: 2/0,1;    # number of open channels / which to use
        delay: 0,0;         # delay in samples for each channel
	maxdelay: -1;	    # max delay for variable delays
	mute: false, false; # mute active on startup for each channel
};

## OUTPUT DEFAULTS ##

output {
        device: "file" {};  # module and parameters to put audio
        sample: "S16_LE";   # sample format
        channels: 2/0,1;    # number of open channels / which to use
        delay: 0,0;         # delay in samples for each channel
	maxdelay: -1;	    # max delay for variable delays
	mute: false, false; # mute active on startup for each channel
        dither: false;      # apply dither
	merge: false;       # merge discontinuities at coeff change
};

## FILTER DEFAULTS ##

filter {
        process: -1;        # process index to run in (-1 means auto)
	delay: 0;           # predelay, in blocks
	crossfade: false;   # crossfade when coefficient is changed
};
</pre>

<p>
The syntax of the main configuration file is very similar as we will
see. As we can see, there are five sections in the configuration:
</p>

<ul>
  <li>General settings. Here the general parameters for BruteFIR is set up.</li>
  <li>Coefficient settings. Parameters for files where-from filter coefficients are loaded.</li>
  <li>Input settings. Settings for digital audio inputs.</li>
  <li>Output settings. Settings for digital audio outputs.</li>
  <li>Filter settings. Parameters for the FIR filters.</li>
</ul>

<p>
The general syntax rules for the configuration files is easily grasped
from the default configuration file. The semicolons are important,
they note the end of a setting, not line breaks, so you may have
several settings on one line if you like. All characters on a line
after a # is found are ignored. There are three data types: strings,
numbers and booleans. Strings are text between quotes, a
number is either with or without a decimal dot, and a boolean is
either 'true' or 'false'.
</p>
<p>
Note that everything is case
sensitive, so setting names must be written with lowercase
letters. Although the configuration file examples shown here is nicely
ordered in sections, you can mix them in any order.
</p>
<p>
The general settings section in the main configuration file has the
same syntax as in the default configuration file. The difference is
that <code>coeff</code>, <code>input</code>, <code>output</code> and
<code>filter</code> structures can exist in multiples, and are given
names and more parameters.
</p>

<h3 id="config_1">General settings</h3>
<p>
Default values of all general settings (except <code>logic</code>) must be
given in the default configuration file. Any of these settings may be
overridden in the main configuration file (except
<code>config_file</code>). These settings are:
</p>

<ul>
  <li>
    <p>
      <code>float_bits: &lt;NUMBER&gt;;</code> internal
      floating point  resolution, either 32 or 64, per default 32, and
      for all  practical uses that is enough. However, if you are the
      kind of person that runs dither on 24 bit output, 64 bit float
      will gain you some extra confidence in the audio precision. With
      modern CPUs and typical applications the extra memory and
      processing requirement is not a problem.
    </p>
  </li>
  <li>
    <p>
      <code>sampling_rate: &lt;NUMBER&gt;;</code> sample rate in Hz.
    </p>
  </li>
  <li>
    <p>
      <code>filter_length: &lt;NUMBER&gt;[,&lt;NUMBER&gt;];</code>
      specifies how long the filters should be, which can be done in two
      ways. Either by specifying the length in one number, which must be
      a power of two. If so, the convolution will be done on the whole
      filter length. To partition a 65536 tap filter in 16 parts, you
      write <code>filter_length: 4096,16</code>. Partitioned filters
      can be used to improve performance and reduce I/O-delay. The
      I/O-delay becomes twice of the partition length, ie 8192 in the
      4096,16 example.
    </p>
    <p>
      There is no formula for calculating the optimal number of partitions
      to get maximum throughput. It varies between hardware platforms, so
      trial and error is the only working method. More than about 16
      partitions are generally not recommended though.
    </p>
    <p>
      If you are using partitioned filters to reduce the I/O-delay for
      realtime filtering, make sure that it does not get too low. If
      I/O-delay is too low, the sound card can get overflowed/underflowed
      causing the program to exit with a broken pipe signal.
      Extremely low latencies, such as 64 sample partitions, may not
      work for long periods of time due to latency variations in the
      kernel.
    </p>
    <p>
      The most loaded CPU core cannot be loaded more than typically 85% for safe
      realtime operation. For very low latencies, this number could go down
      to 70%. The reason for this is that computing time will vary somewhat,
      that is how modern computers work, and to be able to cope with the
      maximum computing times, some spare processor time must be left.
    </p>
  </li>
  <li>
    <p>
      <code>config_file: &lt;STRING&gt;;</code> default location
      of main configuration file.
    </p>
  </li>
  <li>
    <p>
      <code>overflow_warnings: &lt;BOOLEAN&gt;;</code> if set to
      true, information about  overflows will be printed to stderr when they occur. Note that
      overflowed samples are always set to the maximum output value of
      the output device, so there is no actual overflow on the output
      (unless the actual floating point value is overflowed). If
      overflow occurs, it means that the filter is amplifying too much,
      either through its coefficients or through input and output
      attenuation. Overflow is not checked for if the output values are
      floating point.
    </p>
  </li>
  <li>
    <p>
      <code>show_progress: &lt;BOOLEAN&gt;;</code> if true,
      echo progress / realtime index to stderr.
    </p>
  </li>
  <li>
    <p>
      <code>max_dither_table_size: &lt;NUMBER&gt;;</code>
      maximum size in bytes of pre-calculated dither. If dither is
      applied to any output, a dither table will be calculated when the
      program is started. It contains uncorrelated random values that is
      used to generate the dither. The more channels that applies
      dither, the larger table is needed, if to keep the dither
      uncorrelated between channels. This table can get quite large
      memory-wise (in embedded terms). If you want to limit its size,
      set this value. It should rather not be less than one megabyte
      though. If it is set to zero or negative (default), the program
      will itself choose a size.
    </p>
  </li>
  <li>
    <p>
      <code>allow_poll_mode: &lt;BOOLEAN&gt;;</code> if true,
      poll mode is allowed. If a sound card which is used for input
      cannot be configured to have a period size (interrupt interval)
      equal to or smaller than the configured filter (partition) length,
      or if it is cannot be a power of two (note: not common with modern
      hardware), BruteFIR must be run in input poll mode. This means
      that the sound card is polled for data, and sound card interrupts
      are not used. BruteFIR will run just as reliably (as long as the
      sound card allows for small transfers) but will consume more of
      the spare processor time. Thus it will look like BruteFIR uses
      more processor than it actually needs to. If more processor time
      is used for filtering, less will be used for polling, thus input
      poll mode does not mean that it is not possible to have as long
      filters as running in normal mode. However, for some applications
      (for example when the spare processor time is used by another
      vital program), input poll mode is not suitable, and by setting
      the <code>allow_poll_mode</code> to false (default), BruteFIR will
      exit with an error if input poll mode is required.
    </p>
  </li>
  <li>
    <p>
      <code>modules_path: &lt;STRING&gt;;</code> extra path
      relative to the working directory where to find BruteFIR
      modules. This setting is not available if BruteFIR was compiled
      with SINGLE_MOD_PATH.
    </p>
    <p>
      BruteFIR uses external modules to provide
      sample I/O, and optionally add extra logic. It will search a few
      default directories to find any modules that should be loaded, as
      specified in the configuration. This setting adds an extra
      directory, which is searched first. The value in the created
      default configuration file will be ".", that is the current
      working directory. This setting does not exist if BruteFIR
      is complied with SINGLE_MOD_PATH pointing out only one
      modules directory. Loading binary modules from unclear places can
      be a security problem, so if you are a package maintainer for a
      Linux distro, it is recommended to build with SINGLE_MOD_PATH set
      to make sure modules can only be loaded from one specific fixed
      directory.
    </p>
  </li>
  <li>
    <p>
      <code>logic: &lt;STRING: logic module name&gt; { &lt;logic
	module parameters&gt; }[, ...];</code> If any logic modules
      should be loaded, these are listed in the <code>logic</code> field,
      in pairs of module name / module parameters, separated with
      commas. Which logic modules that are available and what
      functionality they provide can be found in
      the <a href="brutefir.html#bflogic">Logic modules</a> section.
    </p>
  </li>
  <li>
    <p>
      <code>powersave: &lt;BOOLEAN or NUMBER&gt;;</code>
      pause filtering when input is zero to reduce CPU load.
    </p>
    <p>
      If activated, will monitor the
      inputs, and if an input channel provides zero samples, the
      associated filters will not do any processing, since with zero on
      the input, BruteFIR knows in advance that there will be zero on the
      output. BruteFIR will continue run as normal, and filters with
      non-zero inputs will continue to to process normally. As soon as
      there is non-zero input on a suspended filter, it starts processing
      again. This powersave feature is transparent, there will be no
      convolution errors if it is activated. The reason for having it
      optional is that one may want to make performance tests, without the
      need to feed a meaningful signal to BruteFIR.
    </p>
    <p>
      If analog inputs are
      used, the input will never be exactly zero, and thus the powersave
      feature will not be triggered. However, if a value is specified
      instead of the boolean (for
      example <code>powersave:&nbsp;-80;</code>), that value is
      interpreted as the lowest level in dB the input signal can be,
      before BruteFIR will consider the input as zero, and trigger
      powersave. Thus, a noise floor can be specified, and then
      powersave can work together with analog inputs.
    </p>
  </li>
  <li>
    <p>
      <code>monitor_rate: &lt;BOOLEAN&gt;;</code> monitor
      sample rate, and abort if it changes. Useful for systems where
      you want to restart with appropriate filter coefficients for the
      sample rate when it changes.
    </p>
  </li>
  <li>
    <p>
      <code>lock_memory: &lt;BOOLEAN&gt;;</code> try to lock
      memory if realtime prio is set, to make sure no memory is put in
      the swapfile (if available) that can jeopardize realtime
      performance.
    </p>
  </li>
  <li>
    <p>
      <code>sdf_length: &lt;NUMBER&gt;[, &lt;NUMBER&gt;];</code>
      sub-sample delay filter half length in samples, and
      optionally a second number with kaiser window beta. Sub-sample
      delays are only needed in very special applications so the
      default value is -1, that is off. If sub-sample
      delays should be possible to set, the <code>sdf_length</code>
      setting must be larger than zero. It specifies the half length of
      a sub-sample delay filter. A sub-sample delay filter is simply a sinc sampled
      with a sub-sample offset. Thus, when a signal is convolved with
      the filter it is delayed with the corresponding offset. Since a
      sinc signal is infinitely long, it must be windowed. A kaiser window
      is used, default beta is 9.0, but an own value can be specified by
      adding it after a comma (example: <code>sdf_length: 31, 8.5;</code>),
      there is little reason to use other than the default though.
    </p>
    <p>
      The
      distortion caused by the windowing is a soft rolloff at higher
      frequencies, the shape depends on the beta value. There is no phase
      distortion. Since the sub-sample filters are linear phase, they will
      add a pre-response (in practice I/O-delay), which is their half filter
      length, that is the value given after the <code>sdf_length</code>
      setting. If sub-sample delay are used only on inputs or outputs, the
      added pre-response is the same as the <code>sdf_length</code>, if used on
      both (usually not necessary), it will be twice the length. To activate
      sub-sample delay, also a valid <code>subdelay</code> must be specified in
      at least one of the input/output structures. The valid range is -99 to
      99.
    </p>
    <p>
      The advantage of a long sub-sample filter length is that the rolloff
      in the high frequencies starts later and gets sharper, that is less
      high frequency information is lost. The disadvantage of long
      sub-sample filters is that the required CPU time increases, and the
      added I/O-delay increases. Sub-sample filters are processed separately
      in the frequency domain using FFT, and therefore it is recommended to
      keep <code>sdf_length</code> at a power of two minus one (the actual
      filter length is twice <code>sdf_length</code> plus one), which means that
      as much as possible of the FFT block is used (an <code>sdf_length</code>
      of 16 requires as much CPU time as an <code>sdf_length</code> of 31, since
      the same block length is required). With an <code>sdf_length</code> of 31
      and the default beta of 9.0, and a sample rate of 44100 Hz, the
      response is flat up to 19 kHz, and then a soft rolloff begins which
      reaches -0.20 dB at 20 kHz, which is good enough for most needs. The
      next natural step, 63, keeps a flat response up to about 20500 Hz,
      with -0.20 dB at 21 kHz.
    </p>
  </li>
  <li><code>convolver_config: &lt;STRING&gt;;</code> specifies
    where FFTW wisdom should be stored, that is optimization
    information for the FFT calculations.</li>
  <li><code>benchmark: &lt;BOOLEAN&gt;;</code> if true, start
    in benchmark mode (can only be used in main config file) which will
    then print performance statistics to the terminal.</li>
  <li><code>safety_limit: &lt;NUMBER&gt;;</code> if non-zero
    max dB in output before aborting. The purpose is to protect your
    ears and expensive speakers. Every output sample is checked and if
    it exceeds this value (in dB) BruteFIR will immediately exit with
    an error message, before any sound is sent to the output.
  </li>
</ul>


<h3 id="config_2">General structure syntax</h3>

<pre>
&lt;structure type name&gt; &lt;STRING: name (list for some) | NUMBER: index&gt; {
	&lt;field name 1&gt;: &lt;setting 1&gt;;
	[...]
};
</pre>

</p><p>
Names of structures (given after the type name) is not given in the
default configuration file, but must be provided in the main
configuration file. The name is either a custom string, or an index
number, which must then be the same as the order of the structure in
the file, that is the first structure must be indexed 0, the second 1
and so on. If a string name is given, the index number is given
automatically (the opposite also applies), and when referring to the
structure, either the string name or the index number can be used.
Some structures, namely input and output, may have a
comma-separated list of names, since the names applies to the channels
defined in the structure.
</p><p>
After the name, or the structure type name if in the default
configuration file, There is a left brace ({), and then structure
fields and their settings, each field/setting pair ending with
semicolon (;). As for the general settings, field names always end
with a colon (:). The order of the fields is not important. The
structure is closed with a right brace (}) and ended with a semicolon.
</p>

<h3 id="config_3">Coeff structure</h3>

<pre>
coeff &lt;STRING: name | NUMBER: index&gt; {
	filename: &lt;STRING: filename&gt;; | &lt;NUMBER: shmid&gt;/&lt;NUMBER: offset&gt;/&lt;NUMBER: blocks&gt;[,...];
	format: &lt;STRING: sample format string | "text" | "processed"&gt;;
	attenuation: &lt;NUMBER: attenuation in dB&gt;;
	blocks: &lt;NUMBER: length in blocks&gt;;
	skip: &lt;NUMBER: bytes to skip in beginning of file&gt;;
	shared_mem: &lt;BOOLEAN: allocate in shared mem&gt;
};
</pre>

<p>
In the default configuration file, the <code>filename</code> field is not
set, so it must be present in the main configuration file.
</p><p>
The coeff structure defines a set of filter coefficients, which
becomes a FIR filter. There are several different file formats:

<ul>
  <li><code>"text"</code> coefficients are listed in a text file, one
    coefficient per line. They are parsed with the standard C library
    <code>strtod()</code> function.</li>
  <li>A sample format string describing a raw format, for example 16 bit
    little endian integer. The format of this string is described in the
    <a href="brutefir.html#config_4">Input and output structure</a> section.</li>
  <li><code>"processed"</code> coefficients are stored in the format
    BruteFIR uses internally. Attenuation or adapted length cannot be
    applied if this format is used.</li>
</ul>

</p>
<p>
  The coefficients can be scaled, by setting the attenuation to non-zero.
</p>
<p>
  The <code>blocks</code> field says how long in filter blocks the coefficient
  set should be. If it is set to -1, the full length is assumed. Note
  that custom lengths are only possible if partitioned convolution is
  employed (quite naturally, since else there will only be one filter
  block covering the full length).
</p>
<p>
  The <code>skip</code> field if given specifies how many bytes in the
  beginning of the file that should be skipped. This can be used to skip
  headers in a file or similar. The field will be ignored if the
  coefficients are not read from file.
</p>
<p>
  In some cases, when one wants to test the performance of a certain
  BruteFIR configuration, but don't feel like generating coefficients,
  one can set the filename to <code>"dirac pulse"</code>. Then BruteFIR will
  generate a dirac pulse filter internally and use it as any other
  filter, and thus will cost as much in processing as any other filter
  of the same length. However, if you need a dirac pulse in the real
  case, it makes no sense using this feature, since simply setting the
  coeff field in the filter structure to -1 gives the same effect and
  uses very little processor power (and memory).
</p>
<p>
  Instead of a filename, comma-separated number groups can be given.
  The first number will be a shared memory ID (man shmat) where the data
  is found, the second number is the offset in bytes into the shared
  memory area where the program starts to read, and the third is how
  many blocks that should be read. A block is a filter segment, that is
  if <code>filter_length</code> is <code>4096,16</code> one block is 4096
  coefficients, and there can be no more than 16 blocks per coefficient
  set. If not all blocks covered in the first group, there must be
  following number groups to provide the full length. When a shared
  memory segment is given, it is required that the format is
  <code>"processed"</code>.
</p>
<p>
  The shared memory and <code>"processed"</code> format features are
  inteded for application developers that need to provide and
  or/modify filter coefficients from a different process while
  BruteFIR is running. The processed format is not documented but an
  API for it exists in the module API so it can quite easily be
  extracted/copied if needed. For normal stand-alone use there is no
  need to used these features.
</p>
<p>
  The <code>shared_mem</code> field indicates if the coefficient should be
  stored in shared memory. In legacy versions of BruteFIR which used a
  multi-process design this was required by some logic modules like the
  equalization module. Today when BruteFIR is threaded all modules have
  access to all memory so it's not needed for that reason. However, if
  you develop a separate application which need to work with the filter
  coefficients while BruteFIR is running the shared memory features are
  still applicable.
</p>

<h3 id="config_4">Input and output structure</h3>

<pre>
input &lt;STRING: name | NUMBER: index&gt;[, ...] {
        device: &lt;STRING: I/O module name&gt; { &lt;I/O module settings&gt; };
        sample: &lt;STRING: sample format&gt;;
        channels: &lt;NUMBER: open channels&gt;[/&lt;NUMBER: channel index&gt;[, ...]];
	delay: &lt;NUMBER: delay in samples&gt;[, ...];
	subdelay: &lt;NUMBER: additional delay in 1/100th samples (valid range -99 - 99)&gt;[, ...];
	maxdelay: &lt;NUMBER: maximum delay for dynamic changes&gt;;
	individual_maxdelay: &lt;NUMBER: maximum delay for dynamic changes&gt;[, ...];;
	mute: &lt;BOOLEAN: mute channel&gt;[, ...];
	mapping: &lt;NUMBER: channel index&gt;[, ...];
};

output &lt;STRING: name | NUMBER: index&gt;[, ...] {
        device: &lt;same syntax as for the input structure&gt;;
        sample: &lt;same syntax as for the input structure&gt;;
        channels: &lt;same syntax as for the input structure&gt;;
	delay: &lt;same syntax as for the input structure&gt;;
	subdelay: &lt;NUMBER: additional delay in 1/100th samples (valid range -99 - 99)&gt;[, ...];
	maxdelay: &lt;same syntax as for the input structure&gt;;
	individual_maxdelay: &lt;same syntax as for the input structure&gt;;
	mute: &lt;same syntax as for the input structure&gt;;
	mapping: &lt;same syntax as for the input structure&gt;;
	dither: &lt;BOOLEAN: apply dither&gt;;
	merge: &lt;BOOLEAN: merge discontinuities at coeff change&gt;;
};
</pre>

<p>
All fields for the input and output structures except
<code>mapping</code>, <code>delay</code> and <code>mute</code>
must be set in the default configuration file.
</p><p>
The device field specifies the source/destination of the digital
audio. This is always an I/O module. First the name of the module is
stated, followed by a its configuration within {}. If the audio is
read/written from/to a module which does not continue forever (for
example reading from a file), BruteFIR will finish when the first I/O
module comes to an end (hopefully an input module, write failure of an
output module is considered an error).
</p><p>
The sample format should be one of the following strings:

<ul>
  <li>"S8", signed 8 bit integer.</li>
  <li>"S16_LE", signed 16 bit little endian integer.</li>
  <li>"S16_BE", signed 16 bit big endian integer.</li>
  <li>"S24_LE", signed 24 bit little endian integer.</li>
  <li>"S24_BE", signed 24 bit big endian integer.</li>
  <li>"S24_4LE", signed 24 bit little endian integer, stored in the high
    bits of 4 bytes.</li>
  <li>"S24_4BE", signed 24 bit big endian integer, stored in the high
    bits of 4 bytes.</li>
  <li>"S32_LE", signed 32 bit little endian integer.</li>
  <li>"S32_BE", signed 32 bit big endian integer.</li>
  <li>"FLOAT_LE", 32 bit little endian floating point.</li>
  <li>"FLOAT_BE", 32 bit big endian floating point.</li>
  <li>"FLOAT64_LE", 64 bit little endian floating point.</li>
  <li>"FLOAT64_BE", 64 bit big endian floating point.</li>
  <li>"&lt;X&gt;_NE", native endian, &lt;X&gt; is replaced with S16,
    S16_4 etc, and the format will be converted to the LE or BE
    counterpart depending on if the machine is little endian or big
    endian.</li>
  <li>"AUTO", will be converted to one of the LE or BE formats (or S8),
    as decided by the associated I/O module.</li>
</ul>

</p>
<p>
The common format 16 bit signed little endian found in for example 16
bit wav-files is thus "S16_LE". The floating point formats can be in
any range, however all integer formats will be scaled to -1.0 to +1.0
internally, so if to match an integer format, the range should be -1.0
to +1.0. There is no overflow checking for floating point formats
(that is values larger than +1.0 or lesser than -1.0 is not truncated).
</p>
<p>
The channels field specifies the number of open and used channels of
the device. If the number of open channels exceed the number of used
channels, a slash (/) followed by a comma-separated list of channel
indexes of used channels must be appended. If we for example have a
eight channel ADAT sound card, but we only want to use the first two,
we write 8/0,1 as the channels setting. As you see, the lowest channel
index is zero, not one.
</p>
<p>
The length of the list of names (given after the structure type name)
must match or exceed the number of used channels. If there are more
channels in the head (the logical, or virtual channels) than there are
available through the device, the specified channels must be mapped
onto the physical device channels. This is done with the
<code>mapping</code> field, which simply is a list of indexes, which index
in the head to map to which physical device channel. Here a simplified
example:
</p>

<pre>
output 14,15,16 {
        ...
        channels: 8/5,4;
	mapping: 0,1,0;
};
</pre>

<p>
In this example, two channels from the eight channel device are used,
channels with index 5 and 4. The order of the channel indexes matter,
physical channel 5 will now be considered the first (index 0) of the
available physical channels, and 4 the second (index 1). The
<code>mapping</code> fields tells how to map the channels called 14, 15
and 16 in the header to those two physical channels. The mapping is in
the same order as the channels in the header, that is 14 is mapped to
physical channel index 0 (which is channel 5 on the eight channel
device), 15 to index 1 (channel 4 on the device), and 16 to index 0,
that is the logical channels 14 and 16 will mix into the same output
on the device. In the standard case, where logical channels are the
same as the amount of channels made available through the
<code>channels</code> field, a <code>mapping</code> specification is not
needed. Then the first logical channel is mapped to the first listed
device channel and so on.
</p>
<p>
The list of delays specifies how many samples a channel should be
delayed. This could be used to compensate for speaker positions that
is either to close or too far away. It could also be used to
compensate for acasual filters. Delay can be changed in runtime, if
<code>maxdelay</code> is not set to a negative value. It defines the upper
bound of delay in samples. When the program is started, delay buffers
for all channels to match maxdelay is allocated. If it is negative,
only the precise amount specified by the delay array is allocated.
</p>
<p>
The setting <code>individual_maxdelay</code> was added later, and works
the same as <code>maxdelay</code> with the difference that it is specified
per channel. It is useful to save memory when there are many channels,
and only some of them need dynamic delay (or considerably larger
buffer than the others).
</p>
<p>
If the general setting <code>sdf_length</code> is larger than zero, the
<code>subdelay</code> setting will take effect. It specifies the
sub-sample delay per channel in 1/100th of samples (valid range is -99
to 99). This delay can be changed in runtime. To disable sub-sample
delay on a channel, set its sub-delay to a negative value outside the
valid range. Since sub-sample delay consumes CPU time, it is
recommended to only activate it where necessary. Sub-delay filters
adds pre-response, and therefore all channels with sub-delay disabled
will be automatically compensated with an I/O delay to make them
aligned.
</p>
<p>
The mute list of booleans, specifies, in order, which channels that
should be muted from the beginning. The muted channels can later be
unmuted from the CLI.
</p>
<p>
If the dither flag is set to true, dither is applied on all used
channels. Dither is a method to add carefully devised noise to improve
the resolution. Although most modern recordings contain dither, they
need to be re-dithered after they have been filtered for best
resolution. Dither should be applied when the resolution is reduced,
for example from 24 bits on the input to 16 bits on the
output. However, one can claim that dither should always be applied,
since the internal resolution is always higher than the output. When
BruteFIR is compiled with single precision, it is not possible to
apply dither to 24 bit output, since the internal resolution is not
high enough. BruteFIR's dither algorithm is the highly efficient HP
TPDF dither algorithm (High Pass Triangular Probability Distribution
Function).
</p>
<p>
If the merge flag is set to true, discontinuities that may occur when
coefficients are changed in runtime, is smoothed out with a simple
merge algorithm. This avoids "clicks" that may occur in the sound when
coefficients are changed. Note that discontinuities occurs also when
volume is changed, but that is not merged, since those discontinuities
are generally not audible or masked by the volume change itself.
</p>

<h3 id="config_5">Filter structure</h3>

<pre>
filter &lt;STRING: name | NUMBER: index&gt; {
        from_inputs: &lt;STRING: name | NUMBER: index&gt;[/&lt;NUMBER:attenuation in dB&gt;][/&lt;NUMBER:multiplier&gt;][, ...];
        from_filters: &lt;same syntax as from_inputs field&gt;;
        to_outputs: &lt;same syntax as from_inputs field&gt;;
        to_filters: &lt;STRING: name | NUMBER: index&gt;[, ...];
	coeff: &lt;STRING: name | NUMBER: index&gt;;
	delay: &lt;NUMBER: pre-delay in blocks&gt;;
	crossfade: &lt;BOOLEAN: cross-fade when coefficient is changed&gt;;
        process: &lt;NUMBER: process index&gt;;
};
</pre>

<p>
The filter structure defines where a filter is placed and what its
parameters are. This is done in a BruteFIR filter:

<ol>
  <li>Possible attenuation is applied to the inputs, where-after they are
    mixed together.</li>
  <li>The mixed-together inputs are filtered.</li>
  <li>The filter output is copied to the output channels, possibly with
    individual attenuation. Attenuation is however not applicable to
    outputs going to other filters.</li>
</ol>

</p>
<p>
If an output channel exists in several filter structures, the
filter outputs will be mixed into that channel. Thus, a set of filter
structures defines how inputs and outputs should be copied, mixed and
filtered.
</p>
<p>
With help of the <code>from_filters</code> and <code>to_filters</code> fields,
filters can be connected to each-other. The only real constraint is
that there must be no loops. BruteFIR will detect and point out errors
if such exist in a given filter graph. Note that if possible
coefficients should be pre-convolved rather than put as filters in
series, since a 2N length filter computes much faster than two
cascaded N length filters.
</p>
<p>
The <code>from_inputs</code>, <code>from_filters</code> and <code>to_outputs</code> fields have the same
syntax. One channel/filter is given as the string name or index
number, and if attenuation should be applied, it is followed by a
slash (/) and attenuation in dB. Instead of, or combined with,
attenuation in dB, a multiplier can be given, a number which all
samples will be multiplied with. The writing <code>"channel
1"/6/-1</code> means that channel 1 is attenuated 6 dB and the polarity
is changed (multiplication with -1). It is also possible to write
<code>"channel 1"//-0.5</code> which is equivalent to the first example.
</p>
<p>
  If more than one channel should be included, they are separated with
  commas. The <code>to_filters</code> field has the same syntax with the
  exception that attenuation is not allowed.
</p>
<p>
  The remaining filter settings are:
</p>
<ul>
  <li>
    <p>
      <code>coeff: &lt;STRING | NUMBER&gt;;</code>
      specifies which coefficient set that should be used for
      the filter. It could be given as the string name of the set, or as its
      index number. If the index number is set to minus one (-1), there will
      be no filtering in the filter, it will just mix and copy inputs/outputs
      as specified. Note that the length of the coefficient set specifies
      how processor intensive the filter will be.
    </p>
  </li>
  <li>
    <p>
      <code>delay: &lt;NUMBER&gt;;</code> specifies how many filter
      blocks pre-delay there should be. Zero or negative means no
      delay. The maximum allowed delay is one block less than full
      length. Thus, with unpartitioned filtering there can be no delay
      at all. For this type of blocked delay the cost is zero both in
      terms of memory and processing.
    </p>
  </li>
  <li>
    <p>
      <code>crossfade: &lt;BOOLEAN&gt;;</code> if set to true, there will be a
      cross-fade when the coefficient is changed in runtime, making the
      coefficient change totally seamless. This means that when changing
      coefficient (using the CLI for example), the filter will convolve one
      block with the old coefficient, fade out that and mix it with a fade
      in block with the new coefficient. This means that at the
      time of coefficient change, there will be roughly twice the amount of
      processing for that filter. This processing spike can of course cause
      buffer underflow if running with a sound card and heavy CPU load in
      the normal case. If there for example are 10 filters in a
      configuration (all with crossfade active), and all coefficients are
      changed at the same time, the normal CPU load should not exceed 50%,
      since the spike will roughly require twice the load. However, if the
      coefficients are changed only one filter at a time, only 10% extra
      processing is required compared to the normal case in the example.
    </p>
  </li>
  <li>
    <p>
      <code>process &lt;NUMBER&gt;;</code> specifies in which thread
      (0, 1, 2, etc) the filter should be run. In legacy versions this
      was actual separate processes, hence the name. This is used for
      manual load balancing. If set to -1 (ie left out as -1 is
      normally already set in the default config), an automatic but
      naive load balancing will take place which for most applications
      is good enough. But with this you can hand-tune if you want.
    </p>
    <p>
      All filters with the same process index will run in the same
      thread. Process index 0 must exist, and if there are more
      processes they should be consecutive, 0, 1, 2, 3 and so on. The
      optimal situation is that there is one filter thread
      per CPU core, and that each filter thread requires the same
      processor time. Then you will get most out of your multi-core
      CPU. There is one limitation of how filters can be distributed
      between threads: mixing to an output channel or a filter input
      must be done within the same thread.
    </p>
  </li>
</ul>

<h3 id="config_6">Configuration file example</h3>
<p>
Here follows an example of a main configuration file, showing some of
the aspects of BruteFIR's possibilities. It implements a cross talk
cancellation filter for a stereo dipole. Note that the configuration
uses the default settings extensively. For example, no general
settings have been specified apart from the addition of the CLI logic
module, and in the coeff structures, only the filename field is used.
</p>

<pre>
logic: "cli" { port: 3000; };

coeff "direct path" {
        filename: "direct_path.txt";
};

coeff "cross path" {
        filename: "cross_path.txt";
};

input "left", "right" {
        device: "file" { path: "/disk0/tmp/music.raw"; };
        sample: "S16_LE";
        channels: 2;
};

output "stereo dipole left", "stereo dipole right" {
        device: "file" { path: "output01.raw"; };
        sample: "S16_LE";
        channels: 2;
};

filter "left speaker direct path" {
        inputs: 0/6.0;
        outputs: 0;
	coeff: "direct path";
};

filter "left speaker cross path" {
        inputs: "right"/6.0;
        outputs: "stereo dipole left";
	coeff: "cross path";
};

filter "right speaker direct path" {
        inputs: "right"/6.0;
        outputs: "stereo dipole right";
	coeff: "direct path";
};

filter "right speaker cross path" {
        inputs: "left"/6.0;
        outputs: "stereo dipole right";
	coeff: 1;
};
</pre>

<h2 id="bfio">I/O modules</h2>
<p>
I/O modules are used to provide sample input and output for the
BruteFIR convolution engine. It is entirely up to the I/O module of
how to produce input samples or store output samples. It could for
example read input from a sound card, a file, or simply generate
noise from a formula.
</p><p>
In the BruteFIR configuration file, an I/O module is specified in each
input and output structure.
</p><p>
The purpose of having I/O modules instead of building all
functionality directly into BruteFIR is that it should be easy to extend
with new functionality, without compromising the core convolution
engine.
</p><p>
All I/O modules has the extension ".bfio".
</p>

<h3 id="bfio_alsa">ALSA sound card I/O (alsa)</h3>
<p>
The ALSA I/O module (named "alsa") is used to read and write samples
from/to sound cards using the low-level Linux sound system.
</p>
<p>
When using the "hw" devices it's the closest to the hardware
integration and therefore the recommended way to integrate BruteFIR on
systems where there is no need to have a sound server running like
JACK or PipeWire. On a desktop computer with a sound server running
you generelly cannot use the "hw" device as it's already used by the
sound server.
</p>
<p>
In addition to the hardware devices, there are usually one or more
virtual devices made available through ALSA but these do not provide
direct access to the underlying sound hardware. On a desktop computer
where the sound hardware is shared by many applications it may be
useful to use these devices, but if you use a sound server like JACK
or PipeWire it's better to use the provided dedicated I/O module
instead.
</p>
<p>
The module has the following configuration options:
</p>
<ul>
  <li><code>device:  &lt;STRING&gt;;</code> (required), the sound
    device to use. Preferably use a "hw" (direct hardware access)
    whenever possible. Use for example "arecord -L" ALSA tool to list
    available input devices and "aplay -L" to list available output
    devices. A typical name looks like this: "hw:CARD=Device,DEV=0",
    but can also be indexed by numbers like this: "hw:2,0,0". Devices
    can also be found directly under /proc/asound</li>
  <li><code>ignore_xrun: &lt;BOOLEAN&gt;;</code> default
    false. Per default, when reading fails due to an overflow, or writing fails
    due to and underflow, BruteFIR will abort. If your computer is heavily
    loaded, and/or partitions are short, and/or other services are running
    on the computer, over/underflow can occur occasionally. In those
    cases, one might rather get occasional clicks in the sound rather than
    a total stop. By setting this to true, the ALSA I/O module will hide
    over/underflow from BruteFIR, and thus it will not abort when that
    occurs.</li>
  <li><code>link: &lt;BOOLEAN&gt;;</code> default true, which
    links all ALSA devices together (inputs and outputs) such that
    they start in a syncronized fashion. Only disable this if there is
    a problem at startup.</li>
  <li><code>access: &lt;STRING&gt;;</code> force an access mode
    instead of using automatic. Automatic works in almost all cases
    except for quirky drivers like the ALSA loopback driver. The
    following modes exist:</li>
  <ul>
    <li>MMAP_INTERLEAVED</li>
    <li>MMAP_NONINTERLEAVED</li>
    <li>RW_INTERLEAVED</li>
    <li>RW_NONINTERLEAVED</li>
  </ul>
</ul>
<p>
In addition to this the common sample format and channels settings
affects how the sound device is opened. For example if you want to use
only channel 3,4 of an 8 channel sound card you set <code>channels:
  8/3,4</code>. All BruteFIR sample formats that is also supported by
the selected device can be used.
</p>
<p>
If you use ALSA for both input and output, you need to make sure the
devices used have the same clock source, or else they may drift apart
over time causing underflow/overflow.
</p>
<p>
The ALSA Loopback device can be used for simple integration cases like
if you want a streaming audio application feed sound to BruteFIR which
then sends to the output, but in most cases it's easier to use JACK
I/O if it needs to integrate with other audio applications.
</p>

<h3 id="bfio_jack">JACK audio server I/O (jack)</h3>
<p>
The JACK I/O module (named "jack") provides BruteFIR with support for
the low-latency JACK audio server. If BruteFIR needs to exist together
in a system of other audio applications, using JACK is the preferred
way to handle I/O.
</p>
<p>
To avoid putting I/O-delay into the JACK graph, the JACK buffer size
should be set to the same as the BruteFIR partition size. It is
however possible to set the JACK buffer size to a smaller
value. The I/O-delay in number of JACK buffers as seen by
following JACK clients will be:
</p>

<pre>
2 * &lt;BruteFIR partition size&gt; / &lt;JACK buffer size&gt; - 2
</pre>

<p>
Note that both the JACK buffer size and BruteFIR period size is always
a power of two.
</p>
<p>
  The sample format for the JACK device should be set to <code>AUTO</code>,
  which will be the JACK sample format (floating point).
</p>
<p>
Here are the settings:
</p>
<ul>
  <li>
    <p>
    <code>ports: &lt;STRING: port name&gt;[/&lt;STRING: custom local
    port name&gt][, ...];</code> used to  connect to ports at startup.
    If no ports should be connected, and the rest is left at defaults,
    the JACK device clause is empty (<code>"jack" { };</code>).
    </p>
    <p>
      Examples: <code>"jack" { ports: "alsa_pcm:capture_1", "alsa_pcm:capture_2"; }</code>
      for input, and <code>"jack" { ports: "alsa_pcm:playback_1",
	"alsa_pcm:playback_2"; }</code> for output. The port listing must be
      set to the same amount as the number of channels for the device. However,
      empty strings could be used if a specific channel index should not be
      connected, for example: <code>"jack" { ports: "", "alsa_pcm:capture_2";
	}</code> will only connect the second port.
    </p>
    <p>
      If there is no custom naming, the names of the BruteFIR ports will be
      "brutefir:input-N" for the inputs, and "brutefir:output-N", where
      N is the channel index. Custom names are given like this: <code>"jack" { ports:
	"alsa_pcm:capture_1"/"in-A"; }</code>, that is adding a slash and
      specifying a name after that, this will replace the default "input-N"
      for inputs and "output-N" for outputs. If a port should not be
      connected but still be named, the first string is empty, like this:
      <code>"jack" { ports: ""/"in-A"; }</code>.
    </p>
  </li>
  <li>
    <p>
      <code>clientname: &lt;STRING&gt;;</code> optionally override the
      default JACK client name, which will be "brutefir". It is a global
      setting, and if used it must be set in the first JACK  device
      clause (the first from the top in the configuration file). The
      clientname will change the port name prefix as well (the prefix is
      the client name). If multiple BruteFIR instances should be run,
      they must have different client names, or else the port names will
      collide.
    </p>
  </li>
  <li>
    <p>
      <code>priority: &lt;NUMBER&gt;;</code> optionally specify what
      realtime priority the JACK callback thread will be running
      at. BruteFIR relates its own thread priorities to that to make
      realtime scheduling work ideally and needs to know it in
      advance. It makes a guess, if wrong it will print a warning with
      what value you need to set.
    </p>
  </li>
</ul>
<p>
  In the example configuration below, we set a custom client name to
  override the default "brutefir", and we connect both input ports to
  alsa PCM. On the output we connect only the second port, but we give
  both ports custom names instead of the default "output-0" and
  "output-1".
</p>
<pre>
input "left", "right" {
        device: "jack" {
                clientname: "my-custom-clientname";
                ports: "alsa_pcm:capture_1", "alsa_pcm:capture_2";
        };
        sample: "AUTO";
	channels: 2;
};
output "left", "right" {
        device: "jack" {
                ports: ""/"my-output-A",
                       "alsa_pcm:playback_2"/"my-output-B";
        };
        sample: "AUTO";
	channels: 2;
};
</pre>

<h3 id="bfio_pipewire">PipeWire multimedia server I/O (pipewire)</h3>
<p>
  On current general-purpose Linux desktop computers PipeWire is the
  most popular low-level server for both audio and video that lets
  multiple applications share the same sound hardware.
</p>
<p>
  This I/O module is the likely candidate to use if you want to run
  BruteFIR on your regular desktop computer without any changes. If
  you make a dedicated computer for audio processing you should either
  use ALSA I/O if BruteFIR doesn't need to integrate towards other
  audio applications, and JACK I/O if it has to.
</p>
<p>
  On an interface level PipeWire works the same way as JACK, and the
  I/O module has the exact same configuration as the JACK I/O module,
  just replace "jack" with "pipewire" and connect to PipeWire ports
  either at startup, or connect later using PipeWire graph tools.
</p>

<h3 id="bfio_file">Raw PCM file I/O (file)</h3>
<p>
The raw PCM file I/O module (named "file") is used to read and write
samples from/to files. It supports all BruteFIR sample formats and
reads/writes them directly in raw form, interleaved format.
<ul>
  <li><code>path: &lt;STRING&gt;;</code> (required) path to the
    filename to be opened, either absolute path or relative to the
    work directory.
  </li>
  <li><code>skip: &lt;NUMBER&gt;;</code> (input only) skip the given
    number of bytes in the beginning of the file. Set to 44 if to
    skip the header of classic .wav files.
  </li>
  <li><code>loop: &lt;BOOLEAN&gt;;</code> (input only) loop the file
    over and over again.
  </li>
  <li><code>append: &lt;BOOLEAN&gt;;</code> (output only) if the file
    if it exists should be appended to rather than overwritten.
  </li>
  <li><code>text: &lt;BOOLEAN&gt;;</code> read/write text file instead
    of raw format. The format is N floating point ASCII values per
    line separated with whitespace, where N is the number of channels.
    The module will convert to/from 64 bit floating point, and thus
    requires that sample format (or use <code>AUTO</code>).
  </li>
</ul>
<p>
Here's a trick: by using <code>/dev/stdin</code> on input
and <code>/dev/stdout</code> on output, BruteFIR will read data from
standard input and write to standard output, so you can then use it in
pipes on the command line, like this:
</p>
<pre>
ogg123 -d raw -f - test.ogg | brutefir stdio_config | aplay -f S16_LE -c2 -r48000
</pre>
The input/output configuration for the example above would be:
<pre>
input "left", "right" {
        device: "file" { path: "/dev/stdin"; };
        sample: "S16_LE";
        channels: 2;
};

output "left", "right" {
        device: "file" { path: "/dev/stdout"; };
        sample: "S16_LE";
        channels: 2;
};
</pre>

<h3 id="bfio_own">Writing your own I/O module</h3>
<p>
For this the source code is the documentation. There are two types of
modules, either regular which read/write to/from file descriptiors
like the ALSA and File I/O modules, and then callback-based modules
like the JACK and PipeWire modules.
</p>

<h2 id="bflogic">Logic modules</h2>

<h3 id="bflogic_cli">Command line interface (cli)</h3>
<p>
The CLI logic module (named "cli") provides a command line
interface available through telnet, a local socket, a pipe, or a
serial line. The CLI is used for changing settings in runtime,
which is of course only suitable when BruteFIR is used in
realtime. It can be used interactively by hand, for example by
connecting to it through telnet. It is also suitable for scripting
BruteFIR, or using it as a means of inter-process communication if
BruteFIR is used as the convolution engine for another application.
</p>
<ul>
  <li>
    <code>port: ...;</code> specifies how to connect to the CLI, there
    are these variants to cover different needs:
    <ul>
      <li><code>port: &lt;INTEGER: TCP port number&gt;;</code> the CLI will
	listen on the given port number for incoming telnet clients.</li>
      <li><code>port: &lt;STRING: "/dev/" ...&gt;;</code> when the string starts
	with "/dev/" the CLI assumes a serial device (such as "/dev/ttyS0" on
	Linux) is pointed out, and opens it as a serial port, with the default
	line speed 9600 baud, if not the <code>line_speed</code> setting is used
	specifying another speed.</li>
      <li><code>port: &lt;STRING: name of local socket&gt;;</code> any other
	string not starting with "/dev/" is handled as the file name for a
	local socket, and the CLI will create and listen for incoming
	connections on the given path. If the path exists, it will be
	replaced.</li>
      <li><code>port: &lt;INTEGER: read end file descriptor&gt;, &lt;INTEGER:
	  write end file descriptor&gt;;</code> the CLI will assume that the given
	file descriptors are already opened and ready for use, and will attach
	the read end to CLI input, and the write end to CLI output. This
	interface is suitable as inter-process communication when BruteFIR is
	integrated into another program, and is started through fork() and
	exec().</li>
    </ul>
  </li>
  <li>
    <code>script: &lt;STRING&gt;;</code> CLI script to run, see
    examples further down. If the script is set, the port cannot be
    set.
  </li>
  <li>
    <code>echo: &lt;BOOLEAN&gt;;</code> set to true if to echo back
    the commands. If telnet is used, this is not required and is off
    per default.
  </li>
  <li>
    <code>line_speed: &lt;NUMBER&gt;;</code> optionally set a custom
    line speed for serial line interface. Only used if port specifies
    a serial port.
  </li>
</ul>

<p>
The CLI does not have much terminal functionality to speak of, and is
thus a bit cumbersome to use interactively. It reads a whole line at a
time, and can interpret backspace, but that is about it.
</p>
<p>
Instead of specifying a port, one can specify a string of commands,
which will be run in a loop as a script. Example: <code>"cli" { script:
"cfc 0 0;; sleep 10;; cfc 0 1;; sleep 10"; }</code>. The script may span
several lines. Each line is carried out atomically (this is also true
for command line mode), so if there are several commands on a single
line, separated with semicolon, they will be performed atomically (an
atomic set of statements). The exception is when an empty statement is
put in the line (just a semicolon), like in the script example, this
will work as a line break, and thus separate atomic sets of
statements.
</p><p>
A typical use for atomic set of statements is to change filter
coefficients and volume at the same time.
</p><p>
The <code>sleep</code> function in the CLI allows for sleeping in seconds,
milliseconds or blocks. One block is exactly the filter length in
samples, and if partitioned, it is the length of the partition. Block
sleep can only be used in script mode.
</p><p>
When in script mode, the first atomic statements will be executed
just before the first block is processed, then the block is processed
(and sent to the output), and then the next set of atomic statements
is run. That is, each set of atomic statements is performed before the
corresponding block is processed. The next atomic statement set is not
performed until the next block is about to be processed.
</p><p>
The block sleep command (only works in script mode) works such that
the sleep is commenced at the next block. The statement
<code>sleep&nbsp;b1;</code> will thus cause the next block to be
skipped. Note that since one block passes for each atomic statement
set, a single line with only <code>sleep&nbsp;b1;</code> will skip two
blocks, not one, since one block is consumed when parsing the sleep
command, and the other is skipped by the sleep duration. That is to
skip only one block, either use <code>sleep&nbsp;b0;</code> alone, or use
<code>sleep&nbsp;b1</code> as the last statement together with other
statements in an atomic statement set (recommended).
</p><p>
Sleep in seconds and milliseconds will start the timer when the
command is issued (at the start of the block if in a script), and
continue with the next command after at least the given time has
passed. If run in a script, the timer is polled at the start of each
block, and the next command is then executed at the start of the first
block where the timer has expired.
</p><p>
If several sleep commands are executed in the same atomic statement
set in a script, only the last will take effect, and will be executed
only when all other commands in the set have been processed. To avoid
confusion, it is thus recommended to employ sleep commands either
alone, or as the last in the atomic statement set.
</p><p>
When connected and you type "help" at the prompt, you will
get the following output:
</p>

<pre>
Commands:

lf -- list filters.
lc -- list coefficient sets.
li -- list inputs.
lo -- list outputs.
lm -- list modules.

cfoa -- change filter output attenuation.
        cfoa &lt;filter&gt; &lt;output&gt; &lt;attenuation|Mmultiplier&gt;
cfia -- change filter input attenuation.
        cfia &lt;filter&gt; &lt;input&gt; &lt;attenuation|Mmultiplier&gt;
cffa -- change filter filter-input attenuation.
        cffa &lt;filter&gt; &lt;filter-input&gt; &lt;attenuation|Mmultiplier&gt;
cfc  -- change filter coefficients.
        cfc &lt;filter&gt; &lt;coeff&gt;
cfd  -- change filter delay. (may truncate coeffs!)
        cfd &lt;filter&gt; &lt;delay blocks&gt;
cod  -- change output delay.
        cod &lt;output&gt; &lt;delay&gt; [&lt;subdelay&gt;]
cid  -- change input delay.
        cid &lt;input&gt; &lt;delay&gt; [&lt;subdelay&gt;]
tmo  -- toggle mute output.
        tmo &lt;output&gt;
tmi  -- toggle mute input.
        tmi &lt;input&gt;
imc  -- issue input module command.
        imc &lt;index&gt; &lt;command&gt;
omc  -- issue output module command.
        omc &lt;index&gt; &lt;command&gt;
lmc  -- issue logic module command.
        lmc &lt;module&gt; &lt;command&gt;

sleep -- sleep for the given number of seconds [and ms], or blocks.
         sleep 10 (sleep 10 seconds).
	 sleep b10 (sleep 10 blocks).
	 sleep 0 300 (sleep 300 milliseconds).
abort -- terminate immediately.
tp    -- toggle prompt.
ppk   -- print peak info, channels/samples/max dB.
rpk   -- reset peak meters.
upk   -- toggle print peak info on changes.
rti   -- print current realtime index.
quit  -- close connection.
help  -- print this text.

Notes:

- When entering several commands on a single line,
  separate them with semicolons (;).
- Inputs/outputs/filters can be given as index
  numbers or as strings between quotes ("").
</pre>

<p>
Most commands are simple and don't need to be further
explained. Naturally, any changes will lag behind as long as
the I/O delay is. The exception is the mute and change delay
commands, they will lag behind as long as the period size of the sound
card is, which most often is smaller than the program's total I/O
delay. However, when there is a virtual channel mapping, the mute and
delay will be lagged as well.
</p><p>
The <code>imc</code>, <code>omc</code> and <code>lmc</code> commands are used to
give commands to I/O modules and logic modules in run-time. To find
out which modules that are loaded and which indexes they have, use the
command <code>lm</code>. Not all modules support run-time commands though.
</p><p>
Changing attenuations with <code>cffa</code>, <code>cfia</code> and
<code>cfoa</code> can be done with dB numbers or simply by giving a
multiplier, which then is prefixed with <code>m</code>, like this <code>cfoa
0 0 m-0.5</code>. Changing the attenuation with dB will not change the sign
of the current multiplier.
</p>

<h3 id="bflogic_eq">Run-time equalizer</h3>
<p>
The equalizer logic module takes control over one or more coefficient
sets, and renders equalizer filters to them, as specified by the
user. This can be done in the initial configuration, and also updated
in runtime, through the CLI.
</p>
<p>
Here is an example configuration with two equalizers, "eq-0" (which is
double-buffered) and "eq-1":
</p>

<pre>
filter_length: 1024,16;
logic:
"eq" {
    debug_dump_filter: "/tmp/rendered-%d";
    {
        coeff: "eq-0", "eq-0-buf"; # double buffered
        bands: "ISO octave";
        magnitude: 31.5/-3.2, 125/8.5;
        phase: 31.5/3.2;
    };
    {
        coeff: "eq-1";
        #bands: "ISO octave";
        #bands: "ISO 1/3 octave";
        bands: 20, 100, 200, 500;
        magnitude: 20/-3.2, 100/8.5;
        phase: 20/0, 100/180;
    };
},
"cli" {
    port: 3000;
};

coeff "eq-0" { filename: "dirac pulse"; };
coeff "eq-1" { filename: "dirac pulse"; blocks: 4; };
coeff "eq-0-buf" { filename: "dirac pulse"; };

filter "a" {
    from_inputs: "left";
    to_outputs: "left";
    coeff: "eq-0";
    crossfade: true;
};
filter "b" {
    from_inputs: "right";
    to_outputs: "right";
    coeff: "eq-1";
};
</pre>

<p>
If you want to analyze the rendered filters, the
<code>debug_dump_filter</code> setting specifies a file name where the
rendered coefficients will be written. It must contain %d, which will
be replaced by the coefficient index. Then follows equalizers. Each
specify which coefficient index (or name) it should render the
equalizer filter to. These must be allocated. If blocks is not
specified the will be as long as the filter length, so if you want
shorter you need to specify that, for example like this:
</p>
<p>
<pre>
coeff 0 {
        filename: "dirac pulse";
	blocks: 4;
};
</pre>

</p>
<p>
The dirac pulse will be replaced by the rendered filter. Each
equalizer has a set of frequency bands (max 128), they can be manually
specified, or use the ISO octave band presets. Optionally, magnitude
(in dB) and phase (in degrees) settings can be specified. The
frequency value must then match one of the given bands.
</p>
<p>
If you specify two filters, the rendering will be double-buffered,
meaning that the eq module will keep one coefficient active in the
filter(s), and render to the other, and switch when ready. This means
that there is no risk of playing an incomplete equalizer, which can cause
some noise (usually in the form of a beep), thus it is recommended to
use double-buffered mode if the equalizer will be altered in
runtime. In the filter configuration and when referring to the
equalizer in the CLI, the first of the two coefficients should then be
used.
</p>
<p>
In run-time, equalizers can be modified through the CLI. An example:
<code>lmc eq 0 mag 20/-10, 4000/10</code> will set the magnitude to -10 dB
at 20 Hz and +10 dB at 4000 Hz for equalizer for coefficient 0. Instead
of <code>mag</code>, <code>phase</code> can be given. The command <code>lmc eq
"eq-1" info</code> will list the current settings for the equalizer
stored in the coefficient called "eq-1", example output:
</p>

<pre>
&gt; lmc eq "eq-0" info
coefficient 0,2:
 band:   31.5  63.0   125   250   500  1000  2000  4000  8000 16000
  mag:   -3.2   0.0   8.5   0.0   0.0   0.0   0.0   0.0   0.0   0.0
phase:    3.2   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0

&gt; lmc eq "eq-0" mag 500/-30
ok

&gt; lmc eq "eq-0" info
coefficient 0,2:
 band:   31.5  63.0   125   250   500  1000  2000  4000  8000 16000
  mag:   -3.2   0.0   8.5   0.0 -30.0   0.0   0.0   0.0   0.0   0.0
phase:    3.2   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0
</pre>

<p>
The more heavily loaded the computer is by convolution, the longer
time it will take to render the new equalizer (usually negligible on
modern CPUs). If the coefficient set it renders to is very short, and
the magnitude and phase response is very detailed (sharp edges etc) it
will not be able to adapt to it fully.
</p>

<h3 id="bflogic_own">Writing your own logic module</h3>
<p>
This is documented through the source code. The CLI and EQ modules are
good templates if you want to make your own.
</p>

<h2 id="tuning">Tuning</h2>

<h3 id="tuning_1">Realtime index</h3>
<p>
BruteFIR calculates a "realtime index" which can be shown through the
CLI, or will be printed periodically to the terminal if the
<code>show_progress</code> flag is true. The realtime index is a floating point
value. When it is 1.0, 100% of the available processing power must be
used at all times to be able to achieve realtime performance. If it is
larger than 1.0, it means that with the current configuration,
BruteFIR will not manage realtime performance.
</p>
<p>
When BruteFIR was first released back in 2001 and used in complex
auralization applications, processing power was often a limiting
factor. Today with modern CPUs and typical simpler applications
BruteFIR may only need less than one percent of avaiable processing
power. That is in most cases you will not need to put much
consideration to the realtime index. But if run the software on an
embedded platform and with long filters it may still be relevant.
</p>
<p>
If your configuration is too demanding for realtime, you should shorten
the filters (or remove channels) until the realtime index is very
close below 1.0, perhaps 0.95. This way you make full use of your
computer. However, if you have multiple CPU cores as is typical today,
it is not as simple. The realtime index will show how much is needed
from the most loaded processor. BruteFIR will load-balance
automatically, but you can also do it manually using the "process"
setting on the filter structures. So, devise your configuration carefully if you have multiple
processors. The number of input and output channels and the filter
length is what steals processor time. The number of filters, dither,
delay, mixing and attenuation is very cheap in comparison.
</p>
<p>
When testing with realtime indexes above 1.0, inputs and
outputs must of course be files. For performance testing, you could
use "/dev/zero" for input and "/dev/null" for output. Also note that
it takes some time for the index to stabilize.
</p>
<p>
The realtime index typically matches the processor load, if running
with a sound card. However, if input poll mode is employed, real time
index can be considerably lower than the processor load, since input
polling is performed in the spare processor time.
</p>

<h3 id="tuning_2">Sample clock problems</h3>
<p>
If you use digital input and output, you may get problems if the sound
card is not configured properly. It is very important that the input
and output sample clock use the same clock as reference. Or else,
micro-differences between the input and output sample clock will make
BruteFIR's IO buffers to slide apart, and eventually make the program
stop. Usually there is an option to set the digital sound card's
sample clock to 'slave'.
</p>
<p>
If you have analog input or output or both, you cannot get this
problem (unless you use several different sound cards, then it will
fail due to differences in clocking).
</p>
<p>
Digital sound cards that work in slave mode allows that the sample
clock is changed in runtime. Usually, this is not what one want for
BruteFIR, since the filters are designed for only one sample
rate. Therefore BruteFIR can be configured to exit if it detects a
sample clock different from the one mentioned in the configuration
file, with the "monitor_rate" setting.
</p>

</ol>
</p>
<br>
<br>
<br>
<br>
<hr>
<em>&copy; Copyright 2001 &ndash; 2006, 2009 &ndash;
  2016, 2020, 2025 <a class="econtact" href="">Anders Torger</a></em>
<script>
  (function () {
      var a,b,c,d,e,f,g; a = "mai"; b = "lto:"; c = "and"; d = "ers";
      e = "@to"; f = "rge"; g = "r.se";
      document.querySelectorAll(".econtact").forEach(function(it) {it.href = a+b+c+d+e+f+g});
      document.querySelectorAll(".econtact-text").forEach(function(it) {it.innerText = c+d+e+f+g});
  })();
</script>
</body>
</html>
